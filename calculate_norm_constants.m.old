%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% script for determining conversion factors Norm/Noraxon, passive&active trials
% Marie Moltubakk 28.1.2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




function [convert_norm_angle_a, convert_norm_angle_b, convert_norm_torque_a, convert_norm_torque_b, convert_norm_velocity_a, convert_norm_velocity_b, convert_norm_direction_b] = calculate_norm_constants(act_or_pas, FP)


%%% subject / file data to be retrieved here
fp = 1; % TODO TMP 

%%% Read file names of corresponding data files

global dm_subjectno dm_timepoint dm_side dm_trial 

%read list of filenames into variables
filenames %%% TODO TMP

% read subject data from CPM file #1
underscore_indices = strfind(dm_CPM1_NX,'_'); 
dm_subjectno = dm_CPM1_NX(1:2);
dm_timepoint = dm_CPM1_NX(underscore_indices(1)+1:underscore_indices(2)-1);
dm_side = dm_CPM1_NX(underscore_indices(3)+2);






%%% Plot settings

global plot_achilles plot_norm plot_emg plot_check plot_us subject_id

plot_check = 0; % turn on/off main checkpoint plots
plot_achilles = 1; % turn on/off troubleshoot plots
plot_norm = 1;
plot_emg = 0;  % RMS 3 EMG channels per trial
plot_us = 1;




%%% Set constants % PROJECTSPECIFIC

% sampling frequencies
global us_zerodispframes noraxonfreq freq_default 

% default conversion factors from Norm manuals and Achilles calibration
global convert_achilles norm_volt_per_degree norm_volt_per_velocity norm_volt_per_nm_a norm_volt_per_nm_b

% conversion factors, calculated per subject (values will be extracted by the script below and inserted to these arrays)
global convert_norm convert_norm_ind_passive convert_norm_ind_active

% cutoff frequencies for filters
global emg_bandpass emg_rms_ms mvc_window_ms 
global angle_cutoff velocity_cutoff torque_cutoff_bandstop torque_cutoff_active angle_cutoff_active velocity_cutoff_active

% column placement in Noraxon data
global column_EMG_start column_EMG_end column_l_gm column_r_gm column_l_gl column_r_gl column_l_sol column_r_sol column_l_tibant column_r_tibant column_gonio column_norm_angle column_norm_torque column_norm_velocity column_norm_direction column_achilles







if strcmpi(act_or_pas,'passive') == 1
    dm_trial = 'PASSIVE';



%     %%% subject/trial identifier
%     subject_id = horzcat('subject ', dm_subjectno, ' ', dm_side, ' ', dm_timepoint, ' ', dm_trial);
%     disp(sprintf(horzcat('----------------', subject_id, '------------------')))



    %%% Calculate individual Norm offset for DIRECTION
    % trial 1
    [convert_ind_direction_b1_volt] = calculate_direction_constants(horzcat('data_convert\', dm_CPM1_NX));
    % trial 2
    [convert_ind_direction_b2_volt] = calculate_direction_constants(horzcat('data_convert\', dm_CPM2_NX));
    % average
    convert_norm_direction_b = mean([convert_ind_direction_b1_volt convert_ind_direction_b2_volt]);



    %%% Calculate individual Norm conversion factors (y = ax + b) for ANGLE
    % Reads raw data from Norm, filter
    % Produces individual conversion factors for angle, prints report

    % trial 1
    [convert_ind_angle_a1, convert_ind_angle_b1] = calculate_angle_constants(angle_cutoff, horzcat('data_convert\', dm_CPM1_NX));
    % trial 2
    [convert_ind_angle_a2, convert_ind_angle_b2] = calculate_angle_constants(angle_cutoff, horzcat('data_convert\', dm_CPM2_NX));
    % average
    convert_norm_angle_a = mean([convert_ind_angle_a1 convert_ind_angle_a2]);
    convert_norm_angle_b = mean([convert_ind_angle_b1 convert_ind_angle_b2]);



    %%% Calculate individual Norm conversion factors (y = ax + b) for VELOCITY
    % Reads raw data from Norm, filter
    % Produces individual conversion factors for velocity, prints report

    % trial 1
    [convert_ind_velocity_a1, convert_ind_velocity_b1] = calculate_velocity_constants(velocity_cutoff, horzcat('data_convert\', dm_CPM1_NX));
    % trial 2
    [convert_ind_velocity_a2, convert_ind_velocity_b2] = calculate_velocity_constants(velocity_cutoff, horzcat('data_convert\', dm_CPM2_NX));
    % average
    convert_norm_velocity_a = mean([convert_ind_velocity_a1 convert_ind_velocity_a2]);
    convert_norm_velocity_b = mean([convert_ind_velocity_b1 convert_ind_velocity_b2]);



    %%% Calculate individual Norm conversion factors (y = ax + b) for TORQUE
    % Uses constants from direction, angle, velocity
    % Uses default A constant from Norm, computes B constant individually based on default A constant
    % Produces individual conversion factors for torque, and prints report

    % torque, A constant
    convert_norm_torque_a = norm_volt_per_nm_a;

    % make an array of the three mV values for B constants from direction 7, angle 2, velocity 6
    convert_ind_torque_b_volt = [convert_norm_ind_passive(7) convert_norm_ind_passive(2)/convert_norm_ind_passive(1) convert_norm_ind_passive(6)/convert_norm_ind_passive(5)];
    % create new B constant by combining offset from Noraxon (in mv * A constant) with default offset from Norm system (in mv * A constant)
    convert_norm_torque_b = (mean(convert_ind_torque_b_volt) * norm_volt_per_nm_a) + norm_volt_per_nm_b;

    % output torque conversion numbers to screen, as text
    report = sprintf(horzcat('INDI Torque conversion factors: a = ', num2str(convert_norm_ind_passive(3)), ', b = ', num2str(convert_norm_ind_passive(4)), '. Offset in millivolt = ', num2str(mean(convert_ind_torque_b_volt)), ' mV.' ));
    disp(report)


    
    
elseif strcmpi(act_or_pas,'stiffness') == 1
    dm_trial = 'STIFFNESS';



%     %%% subject/trial identifier
%     subject_id = horzcat('subject ', dm_subjectno, ' ', dm_side, ' ', dm_timepoint, ' ', dm_trial);
%     disp(sprintf(horzcat('----------------', subject_id, '------------------')))



    %%% Calculate individual Norm conversion factors (y = ax + b) for ANGLE
    % Reads raw data from Norm, filter
    % Produces individual conversion factors for angle, prints report

    [convert_norm_angle_a, convert_norm_angle_b] = calculate_angle_constants(angle_cutoff, horzcat('data_convert\', dm_CPM1_NX));

    %%% variables that are not needed for stiffness trials:
    convert_norm_torque_a = 0;
    convert_norm_torque_b = 0;
    convert_norm_velocity_a = 0;
    convert_norm_velocity_b = 0;
    convert_norm_direction_b = 0;
    
    
    
    
else % ACTIVE
    dm_trial = 'ACTIVE';



%     %%% subject/trial identifier
%     subject_id = horzcat('subject ', dm_subjectno, ' ', dm_side, ' ', dm_timepoint, ' ', dm_trial);
%     disp(sprintf(horzcat('----------------', subject_id, '------------------')))



    %%% Calculate individual Norm offset for DIRECTION
    convert_norm_direction_b = calculate_direction_constants(horzcat('data_convert\', dm_isokin45_NX));
    



    %%% Calculate individual Norm conversion factors (y = ax + b) for ANGLE
    % Reads raw data from Norm, filter
    % Produces individual conversion factors for angle, prints report
    [convert_norm_angle_a, convert_norm_angle_b] = calculate_angle_constants_active(angle_cutoff_active, horzcat('data_convert\', dm_isokin45_NX));



    %%% Calculate individual Norm conversion factors (y = ax + b) for VELOCITY
    % Reads raw data from Norm, filter
    % Produces individual conversion factors for velocity, prints report
    [convert_norm_velocity_a, convert_norm_velocity_b] = calculate_velocity_constants_active(velocity_cutoff_active, horzcat('data_convert\', dm_isokin45_NX));



    %%% Calculate individual Norm conversion factors (y = ax + b) for TORQUE
    % Uses constants from direction, angle, velocity
    % Uses default A constant from Norm, computes B constant individually based on default A constant
    % Produces individual conversion factors for torque, and prints report

    % torque, A constant
    convert_norm_torque_a = norm_volt_per_nm_a;

    % make an array of the three mV values for B constants from direction 7, angle 2, velocity 6
    convert_ind_torque_b_volt = [convert_norm_ind_active(7) convert_norm_ind_active(2)/convert_norm_ind_active(1) convert_norm_ind_active(6)/convert_norm_ind_active(5)];
    % create new B constant by combining offset from Noraxon (in mv * A constant) with default offset from Norm system (in mv * A constant)
    convert_norm_torque_b = (mean(convert_ind_torque_b_volt) * norm_volt_per_nm_a) + norm_volt_per_nm_b;

    % output torque conversion numbers to screen, as text
    report = sprintf(horzcat('INDI Torque conversion factors: a = ', num2str(convert_norm_ind_active(3)), ', b = ', num2str(convert_norm_ind_active(4)), '. Offset in millivolt = ', num2str(mean(convert_ind_torque_b_volt)), ' mV.' ));
    disp(report)


    
end